#**进程保活机制**

　　进程保活：说白了就是尽量的保证你的App不被系统杀死，或者被杀死后，还能后“复活”。以下介绍进程保活的几种常用方式。    
　　Android杀死进程的机制来自于linux的low memory killer，他会对所有的进程进行一个排名，衡量的参数就是oom_adj。此值越大，进程越容易被系统杀死。 一般系统应用oom_adj的值都是小于0的，比如系统的启动init进程，oom_ajd = -16  
 
　　首先我们看一下系统杀死app的优先级(从高到低，越低越容易被杀掉)：  
　　**前台进程：** 你当前正在使用的app进程，这是最后被系统杀死的进程。查看oom_adj，值为0   
　　**可见进程：**  可见进程不包含任何的前台组件，可见进程依然会影响用户在屏幕上可以看到的内容。比如：activity弹出来一个不全屏的Dialog。从代码角度来说：就是调用了onPause，但是没有调用onStop。  
　　**服务进程：**  app进程启动了一个Servie，并且该进程并没有和任何的界面做绑定。  
　　**后台进程：**  app退出后，会持有一个Activity，从代码逻辑上来说，就是activity没有调用onDestroy。  
　　**空进程：** app退出后，不包含任何活动的组件，从代码角度来说就是activity调用了onDestroy，但是系统还没有进行回收。该进程是最先被系统kill的。  
　　　

1。 **<font size = 5>前台服务（带有Notification）</font>**

　　设置前台服务，通过这样的方式，就会出现一个Notification来告知用户，比如QQ音乐。这种实现的方式比较简单：实现Service的时候，通过接口：setForeground(int id, Notification notification)就可以实现前台服务。这个属于上述中的“前台进程”;
　　缺点：会出现一个Notification，这个用户是的感知的，一般用户不喜欢这个东西的存在。  

2。 **<font size = 5>通过Android的系统漏洞实现前台服务（无Notification）</font>**

　　利用系统的漏洞来启动一个前台Service进程。与普通启动方式的区别在于：没有生成一个Notification，用户感知不到（这是一个漏洞，android后续版本可能会随时的关闭）。  
　　API<18：启动前台Service时直接传入一个new Notification()即可。  
　　API>18：同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理（这是个android漏洞，我**自己测试了galaxy s6 android 6.0是可以的**）  
　　**查看是否启动成功：**adb shell dumpsys activity services packagename。回车，查看isForground字段是否为true。  
　　**查看oom_adj值：**oom_adj：这个值越大，标明此进程越容易被回收。系统进程这个值都是小于0的。  
　　adb shell cat /proc/pid(你的进程id)/oom_adj  
　　pid的获取命令：ps | grep 进程名

　　具体的代码如下所示：

```
 @Override public int onStartCommand(Intent intent, int flags, int startId) {
        if (Build.VERSION.SDK_INT < 18) {
            startForeground(GRAY_SERVICE_ID, new Notification());//API < 18 ，此方法能有效隐藏Notification上的图标
        }
        else {
            Intent innerIntent = new Intent(this, SecondService.class);
            startService(innerIntent);
            startForeground(GRAY_SERVICE_ID, new Notification());
        }
}

 public static class SecondService extends Service {

        @Override public void onCreate() {
            super.onCreate();
        }

        @Override public int onStartCommand(Intent intent, int flags, int startId) {
            startForeground(GRAY_SERVICE_ID, new Notification());
            stopSelf();
            return super.onStartCommand(intent, flags, startId);
        }


        @Override public IBinder onBind(Intent intent) {
            return null;
        }
}
```
　　通过上面的代码后，你在查看你进程的oom_adj。你会发现发生了很大的变化。　　

3。 **<font size = 5>通过多进程相互唤醒机制</font>**    

　　**多进程启动：**在老的进程中新启动一个前台进程ServcieNew（通过上述的方案2），SericeNew进程每个一段时间检查换上一个进程是否存在，如果不存在立马启动，或者通过广播的方式发送广播，通知老的进程重新启动业务逻辑。  
　　以通过方波的方式来说明，具体的实现方式如下：  
　　首先在你的老的进程中实现一个静态的（在Androidmaniest.xml中声明该广播）BroadcastReceiver :

```
public class RecoveryReceiver extends BroadcastReceiver {

    private final static String TAG = WakeReceiver.class.getSimpleName();
    private final static int RECOVERY_SERVICE_ID = -110;
    public final static String RECOVERY_ACTION = "com.recovery.receiver";

    @Override public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (RECOVERY_ACTION.equals(action)) {
            Intent wakeIntent = new Intent(context, WakeNotifyService.class);
            //收到此消息后启动自己的业务逻辑
        }
    }
}

```
　　其次在新启动的进程中，每隔一段时间发送一次广播（没有检测老的进行是否还存在），通知老进程启动业务逻辑：

```
private final static int ALARM_INTERVAL = 5 * 60 * 1000; //每个5分钟发送一次广播

 AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
        Intent alarmIntent = new Intent();
        alarmIntent.setAction(RecoveryReceiver.RECOVERY_ACTION);
        PendingIntent operation = PendingIntent.getBroadcast(this, WAKE_REQUEST_CODE, alarmIntent,
                PendingIntent.FLAG_UPDATE_CURRENT);
        alarmManager.setInexactRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), ALARM_INTERVAL,
                operation);
```

　　**验证方式：**adb shell之后，kill掉你的第一个进程，然后等待看两一个Service能不能将该进程启动。

4。 **<font size = 5>通过系统广播来启动进程</font>**

　　Android提供了很多的系统广播，如：  
　　系统重新启动(个人可能应用场景不大)  
　　调用系统相拍照的广播（android4.0新增加了android.hardware.actin.NEW_PICTURE、android.hardware.action.NEW_VIDEO，针对照片类型的APP，应用场景很大）等。  
　　以拍照为例：

```
```


5。 **<font size = 5>通过SysAdapter</font>**



6。 **<font size = 5>通过第三方的推送SDK</font>**  
　　目前业界很多的第三方推送SDK（友盟、极光推送等），都是通过长链接的方式完成推送，我们就可以通过这些sdk来实现进程的保活。


　　**<font size = 5>总结：</font>** 不管你采用哪种方式，当你的进程内存太大了，系统都会将你进程杀掉。以上手段只是辅助手段，**降低进程的内存**才是最最终的手段。
