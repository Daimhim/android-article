# **界面卡顿的优化**

## 原因
　　界面卡顿的原因很简单：UI线程做了太多的工作，从而导致16ms（1000ms/60帧）无法完成一帧的刷新。话不多说，直接上措施。

## 措施

<font size = 5>**1 。 不要在UI线程大量的进行如下操作：**</font>    
  
　　<font size = 3>**a。文件读写操作**</font>   
　　<font size = 3>**b。数据库操作**</font>     
　　<font size = 3>**c。动画操作**</font>  
　　<font size = 3>**d。循环操作**</font>

　　注意：不是进行大量的操作，比如：就在sdcard建立一个文件夹，整个工程代码就调用了一次，再来开一个线程就是浪费资源了，何况有些东西必须在主线程实现，比如动画。  


<font size = 5>**2 。内存优化，不要引起虚拟机大量的GC**</font>     


　　关于内存优化请阅读[内存的泄露和优化相关](内存的泄露和优化相关.md)


<font size = 5>**3 。 布局的优化 避免OverDraw**</font>      
  

　　很多的初学习者都没有听说过OverDraw（屏幕上的一个像素点被渲染了多少次，就像关于画画一样，被重复覆盖画了多少次），更不知道如何打开这个设置，来查看自己界面是否合理最优：   
　　设置-开发者选项-show GPU OverDraw  
　　其中：  
　　没有颜色： 意味着没有overdraw。像素只画了一次。  
　　蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的（若整个窗口是蓝色的，可以摆脱一层）。  
　　绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。  
　　浅红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。  
　　暗红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。  
　　当你的程序已经很庞大，再来修改这些东西就很繁琐了。所以建议一开始进行你项目开发的时候就要想到这这些。尽量使得自己overdraw成都最低，甚至没有。  

　　优化策略：  
　　**a。合并冗余的布局**  
　　可以使用lint工具检测你代码及其布局layout，并学会使用merge来处理  
　　**b。去掉不需要的android:background**  
　　当你的父布局和子布局的背景一致时，应该考虑取出子背景  
　　**c。去掉系统默认的窗口背景**  
　　需要注意的是：setContentView之后执行，否则是无效的

```
getWindow().setBackgroundDrawable(null)
```  
　　**d。使用.9图来做背景**  
　　这种情况经常发生在View需要两层背景，比如ImageView需要设置一个前景和一个背景（其中背景用来做边框），将背景drawable制作成9patch，并且将和前景重叠的部分设置为。  
　　**e。谨慎使用alpha**  
　　假如对一个View做Alpha转化，需要先将View绘制出来，然后做Alpha转化，最后将转换后的效果绘制在界面上。通俗点说，做Alpha转化就需要对当前View绘制两遍。  
　　**f。学会使用ClipRect & QuickReject**  
　　canvas.clipRect()用来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。
　　canvas.quickreject()来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。  
　　具体的使用示例：

```

```

<font size = 5>**4 。 动画处理**</font>  
      
　　Android 5.0之后提供了**RenderThread**:是一个新的由系统控制的处理线程，它可以在UI线程阻塞时保持动画平滑（这是一个很模糊的定义）。它可以处理优化操作与GPU分发，减轻UI线程的压力。这一点从Android 5.0提供的一些列水波纹动画就可以看出来。  
　　如何让自己的动画允许在RenderThread中？
　　
  
<font size = 5>**5 。 线程优先级的处理**</font>  

　　许多人在Java中使用线程的时候，就是很简单的new Thread。但是从来不考虑线程的优先级相关。在Android中，如果你不设置线程的优先级，系统就认为该线程与UI线程优先级一致，系统分配时间片就没有轻重缓急。这样你的UI就受到了你业务逻辑的制约。那么怎样在添加优先级呢，具体如下所示：

```
        new Thread(new Runnable() {
            @Override public void run() {
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
		//do something
            }
        }).start();
```

　　不同的优先级如下所示：  
　　int THREAD_PRIORITY_AUDIO //标准音乐播放使用的线程优先级
　　int THREAD_PRIORITY_BACKGROUND //标准后台程序  
　　int THREAD_PRIORITY_DEFAULT // 默认应用的优先级  
　　int THREAD_PRIORITY_DISPLAY //标准显示系统优先级，主要是改善UI的刷新  
　　int THREAD_PRIORITY_FOREGROUND //标准前台线程优先级  
　　int THREAD_PRIORITY_LESS_FAVORABLE //低于favorable  
　　int THREAD_PRIORITY_LOWEST //有效的线程最低的优先级  
　　int THREAD_PRIORITY_MORE_FAVORABLE //高于favorable  
　　int THREAD_PRIORITY_URGENT_AUDIO //标准较重要音频播放优先级  
　　int THREAD_PRIORITY_URGENT_DISPLAY //标准较重要显示优先级，对于输入事件同样适用。  


<font size = 5>**6 。 一些接口的优化处理**</font>    

　　1. List的removeAll接口  
　　这个接口在进行大量数据（上千）的操作时，有些机器卡顿很明显。
